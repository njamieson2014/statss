# -*- coding: utf-8 -*-
"""Copy of Hahn Math 24 Lab 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1du8jL-f1-EV60C-OxDXt6bXJXmimmhfQ
"""

import matplotlib.pyplot as plt
from PIL import Image
import imageio.v2 as imageio

def plot(x): #define a function with argument "x"
    fig, ax = plt.subplots() #creates a figure and axis
    im = ax.imshow(x,cmap='gray') #creates an image plot which displays a 2d array as an aimage
    ax.axis('off')  #turns off the axis on the plot
    fig.set_size_inches(20, 20) #sets the size of the figure to 20 inches by 20 inches
    plt.show()

im = imageio.imread('https://lospec.com/palette-list/st-64-natural-1x.png')

plot(im)

im.shape #shape of the image "im", 3 channels deep is the rgb colorway

plot(im[:,40:41,:]) #grabs the 40th value in the figure

im[:,40:41,:] #rgb values for this color

im = imageio.imread('https://lospec.com/palette-list/waverator-1x.png')

plot(im)

im #rbg values for each color displayed



import numpy as np
import matplotlib.pyplot as plt

# Binary image , creates a 3 by 3array
binary_image = np.array([
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
])

binary_image

plt.imshow(binary_image, cmap='gray') #displays the 3x3 array as an image using

# Grayscale image
grayscale_image = np.array([
    [50, 100, 150],
    [200, 255, 200], #creates an array of varying rbg values, from 0-255
    [150, 100, 50]
])
plt.imshow(grayscale_image, cmap='gray', vmin=0, vmax=255) #plot the image in grayscale

# Grayscale image
grayscale_image = np.array([
    [0.2, 0.4, 0.6],
    [0.8, 1.0, 0.8], #set up a similar array using values between 0 and 1 to represnet the 0-255 rbg color values
    [0.6, 0.4, 0.2]
])
plt.imshow(grayscale_image, cmap='gray')

# RGB image
rgb_image = np.array([
    [[255, 0, 0], [0, 255, 0], [0, 0, 255]], #all red, all green, all blue
    [[255, 255, 0], [0, 255, 255], [255, 0, 255]],  #all red+green, all green+blue, all red+blue
    [[128, 128, 128], [255, 255, 255], [0, 0, 0]] #half of all 3, full of all 3, none of all 3
])

rgb_image

plt.imshow(rgb_image)

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]], #same array as above but with ratios instead of 0-255
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],
    [[0.5, 0.5, 0.5], [1, 1, 1], [0, 0, 0]]
])

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]], #same array as above minus the black white and grey
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],

])

rgb_image

plt.imshow(rgb_image*255) #multiply each value by 255 to get full colorway



x = np.zeros((2,2,3)) #creates a 2x2 array with a depth of 3
x[:,:,0] = 1 #set the first color channel(red) to 1(full)
plt.imshow(x) #show x as an image

x = np.zeros((2,2,3))
x[:,:,1] = 1
plt.imshow(x) #same as above but with green

x = np.zeros((2,2,3))
x[:,:,2] = 1
plt.imshow(x) #same as above but with blue

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 0.5
x[:,:,1] = 0.5
x[:,:,2] = 0.5
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 0
x[:,:,1] = 0
x[:,:,2] = 0
plt.imshow(x)



r = np.random.rand() #random number

r



r = np.random.rand() #create a random number for the red channel
g = np.random.rand() #create a random number for the green channel
b = np.random.rand() #create a random number for the blue channel


x = np.zeros((2,2,3)) #create a 2x2 array with a depth of 3

x[:,:,0] = r #set red channel to random number "r"
x[:,:,1] = g #set green channel to random number "g"
x[:,:,2] = b #set blue channel to random number "b"


plt.imshow(x) #show array as an image



for i in range(5):

    z = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    print(r,g,b)

    z[:,:,0] = r
    z[:,:,1] = g
    z[:,:,2] = b

    plt.imshow(z);
    plt.show() #does above(create a random color using random rgb values) 5 times, plots them all together





for i in range(5):

    z1 = np.ones((10,10,3)) #create 2 10x10 arrrays with a depth of 3
    z2 = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    z1[:,:,0] = r
    z1[:,:,1] = g
    z1[:,:,2] = b #same as above

    z2[:,:,0] = 1-r #set second array color value to the opposite color on the rgb spectrum
    z2[:,:,1] = 1-g
    z2[:,:,2] = 1-b

    z3 = np.hstack((z1,z2)) #stack z1 and z2 together horizontally

    plt.imshow(z3);
    plt.show()



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand() #creates a random color using random values for each rbg value
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand() #creates another random color using random value for each rgb
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #averages the two random numbers from each array to make a new third color of the average between the two

z3 = np.hstack((z1,zavg,z2)) #plot all 3 colors horizontally

plt.imshow(z3);
plt.show()



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #same as above

z1a = (z1+zavg)/2 #repeats the averaging process for the inital color plus the averaged color to generate a new average
z2a = (z2+zavg)/2 #average between the average and the other inital color

z3 = np.hstack((z1,z1a,zavg,z2a,z2)) #plot all 5 colors horizontally

plt.imshow(z3); #starting to form a gradient
plt.show()





for i in range(100):

    z1 = np.ones((10,10,3))
    z1[:,:,0] = np.random.rand()
    z1[:,:,1] = np.random.rand()
    z1[:,:,2] = np.random.rand()

    z2 = np.ones((10,10,3))
    z2[:,:,0] = np.random.rand()
    z2[:,:,1] = np.random.rand()
    z2[:,:,2] = np.random.rand()

    zavg = (z1+z2)/2

    z1a = (z1+zavg)/2
    z2a = (z2+zavg)/2

    z3 = np.hstack((z1,z1a,zavg,z2a,z2))

    plt.imshow(z3); #same function as above, run 100 times

    plt.show()



import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):
    """
    Compute the recursive average of the given list of colors.

    Parameters:
    - colors: List of color arrays

    Returns:
    - A new list of color arrays containing the recursive averages.
    """
    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes):
    """
    Generate a visualization of 2 random colors and their recursive averages for a number of passes.

    Parameters:
    - passes: Number of times to apply the recursive averaging process

    Returns:
    - An image showing the 2 endpoint colors and their recursive averages.
    """
    # Start with 2 random colors
    colors = [np.ones((10,10,3)) for _ in range(2)]
    for color in colors:
        color[:,:,0] = np.random.rand()
        color[:,:,1] = np.random.rand()
        color[:,:,2] = np.random.rand()

    # Apply the recursive averaging for the specified number of passes
    for _ in range(passes):
        colors = recursive_average(colors)

    # Horizontally stack the colors
    result = np.hstack(colors)

    return result

for i in range(5): #runs the above funciton 5 times, each time generating two random colors and doing more averages each run
    img = generate_recursive_colors_v2(i)
    plt.imshow(img)
    plt.axis('off')
    plt.tight_layout()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):

    new_colors = [colors[0]] #takes the first element in colors(the input) and asigns it to a new array
    for i in range(1, len(colors)): #for the length of the array "colors",
        avg_color = (colors[i] + new_colors[-1]) / 2.0 #creat a new array called "avg_color" which is the value for the average of the value in the "colors" array and the previous value of the "new colors" array (the first value of the colors array)
        new_colors.extend([avg_color, colors[i]]) #extend the array "new colors" by adding the average color before the current color
    return new_colors

def generate_recursive_colors_v2(passes, initial_colors):

    colors = initial_colors.copy() #colors stars as a copy of "initial_colors", an inputted variale

    for _ in range(passes):
        colors = recursive_average(colors) #performs the above defined function on the array "colors" overwrites the definition of colors to be the value given by the recursive funciton

    result = np.hstack(colors)

    return result

initial_colors = [np.ones((10, 10, 3)) for _ in range(2)] #generates two 10x10 arrays with a depth of 3
for color in initial_colors:
    color[:,:,0] = np.random.rand() #initial colors are generated for each color channel in the generated arrays
    color[:,:,1] = np.random.rand()
    color[:,:,2] = np.random.rand()

passes_values = [0,1,2,3,4] #create an array for the number of passes performed by the funciton
imgs = [generate_recursive_colors_v2(p, initial_colors) for p in passes_values] #creates an image for the inital colors and each case with increasing number of passes

fig, axs = plt.subplots(1, len(passes_values), figsize=(15, 5)) #creates a figures for the length of the #of passes

for ax, img, p in zip(axs, imgs, passes_values):
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(f'Passes={p}')

plt.tight_layout()
plt.show()

"""https://lospec.com/palette-list"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib
import imageio.v2 as imageio
from PIL import Image

def get_colors_lospec(url): #retrieves colors from an image hosted at an inputted url and converts the colors into a custom colormap
    im = imageio.imread(url) #reads the image from a url
    rgb_list = (im/255)[0,:,0:3] #divides the values in the image by 255 to normalize them between 1 and 0, does this for all 3 color channels
    float_list = list(np.linspace(0,1,len(rgb_list)))
    cdict = dict() #stores the rgb values
    for num, col in enumerate(['red', 'green', 'blue']): #rgb values are seperated into each channel
        col_list = [[float_list[i], rgb_list[i][num], rgb_list[i][num]] for i in range(len(float_list))]
        cdict[col] = col_list
    cmp = mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256)#creates a colormap using the the color dictionary "cdict" with 256 colors in the color map
    return cmp

url = 'https://lospec.com/palette-list/agb-32x.png' #32x32 pixels
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/agb-1x.png' #1 pixel
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/moondrom-1x.png'
im = imageio.imread(url)
plt.imshow(im);

z = np.random.randint(0,255,size=(10,10)) #10x10 array of random integers between 0-255

z

plt.imshow(z,cmap='jet')  #displayts the random generated array using a color map inputted, in this case"jet"

plt.imshow(z, cmap=get_colors_lospec(url))
plt.colorbar(); #the color map created by the image earlier

x, y = np.mgrid[-5:5:0.05, -5:5:0.05] #create two equal arrays, one x and one y, that represent the coordinates of points on a grid. they both go from -5 to 5 with 0.05 increments
z = np.sqrt(x**2 + y**2) #magnitude of the two arrays

x

y

z = np.sqrt(x**2 + y**2)

z.shape

plt.imshow(x) #grid is plotted in the x direction

plt.imshow(y) #grid is plotted in the y direciton

z



plt.imshow(z, cmap=get_colors_lospec(url)); #generates a plot using the z values and the generated colorway
plt.show() #taking the magnitude of each x and y value generates a circle for the z array



x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show() #takes the sin of the y term, generates a plot showing the value as the sin wave moves along

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show() #same but taking the sine of the x array

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)*np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show() #multiplying the sin waves together generates a checkerboard patter



import matplotlib.pyplot as plt
import imageio
from PIL import Image
from skimage.io import imread

def plot(x):
    fig, ax = plt.subplots() #creats a figure and an axis object
    im = ax.imshow(x,cmap='gray') #plots a 2d array "x"(the input) on the axes "ax". uses grayscale colorway. imshow displays he fcuntion as an image
    ax.axis('off') #turns off axis, meaning no ticks or labels on the axes
    fig.set_size_inches(20, 20) #set the size of the figures in inches
    plt.show()

im = imread('https://raw.githubusercontent.com/imageio/imageio-binaries/master/images/imageio_banner.png') #reads the image as values and stores them

plot(im) #displays the image from the url

url = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Octopus2.jpg/800px-Octopus2.jpg"

im = imread(url)

plot(im)

im.shape #the shape of the array created by reading the image (609x800 pixels   )

plt.imshow(im[:,:,0],cmap="gray") #show only the red channel in greyscale

plt.imshow(im[:,:,1],cmap="gray") #show only the blue channel in grayscale (lots of blue)

plt.imshow(im[:,:,2],cmap="gray") #show only the green channel in gray scale (lots of green)

r = im[:,:,0]
g = im[:,:,1] #seperates the image into 3 diferent arrays "r", "g", and "b"
b = im[:,:,2]

combo = np.hstack([r,g,b])

plt.imshow(combo,cmap="gray") #show each color channel image, stacked horizontally

